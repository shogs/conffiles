#!/bin/bash
# git-wt - Git subcommand for worktree management
# Place this file in your PATH as 'git-wt' (executable)
# Usage: git wt <command> [args...]

# =============================================================================
# GIT WT SUBCOMMAND - Usage: git wt <command>
# =============================================================================

# Colors for output (with detection)
if [[ -t 1 ]] && command -v tput >/dev/null 2>&1 && tput colors >/dev/null 2>&1 && (( $(tput colors) >= 8 )); then
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    BLUE='\033[0;34m'
    NC='\033[0m' # No Color
else
    RED=''
    GREEN=''
    YELLOW=''
    BLUE=''
    NC=''
fi

show_help() {
    echo -e "${BLUE}Git Worktree Management - Usage: git wt <command>${NC}"
    echo ""
    echo -e "${GREEN}üìã Available Commands:${NC}"
    echo -e "  ${BLUE}new${NC} [branch-name] [base-branch]       - Create new worktree"
    echo -e "  ${BLUE}list${NC}                                - List all worktrees" 
    echo -e "  ${BLUE}switch${NC} [-s|--shell] <branch-name>     - Switch to worktree (optionally start shell)"
    echo -e "  ${BLUE}resume${NC} [-s|--shell] <branch-name>     - Resume work in worktree (optionally start shell)"
    echo -e "  ${BLUE}root${NC}                                 - Switch to repository root"
    echo -e "  ${BLUE}status${NC}                               - Show overall status"
    echo -e "  ${BLUE}clean${NC}                                - Clean up worktrees"
    echo -e "  ${BLUE}task${NC} 'description' [branch]          - Create worktree + start Claude task"
    echo -e "  ${BLUE}help${NC}                                 - Show this help"
    echo ""
    echo -e "${YELLOW}üìÅ Structure: All worktrees are created in .worktrees/ (auto-gitignored)${NC}"
    echo -e "${YELLOW}üîó Integration: Works seamlessly with Claude Code slash commands${NC}"
    echo ""
    echo -e "${GREEN}Examples:${NC}"
    echo "  git wt new auth-feature"
    echo "  git wt task 'Add JWT authentication'"
    echo "  git wt switch auth-feature           # Lightweight switch"
    echo "  git wt switch -s auth-feature        # Switch with shell"
    echo "  git wt resume -s bug-fix             # Resume with shell"
    echo "  git wt root                          # Return to main repo"
    echo "  git wt list"
}

ensure_git_repo() {
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        echo -e "${RED}‚ùå Not in a git repository${NC}"
        exit 1
    fi
}

_is_in_worktree_shell() {
    [ "$GIT_WT_SHELL" = "1" ]
}

_exit_worktree_shell() {
    if _is_in_worktree_shell; then
        echo -e "${BLUE}üè† Exiting worktree shell and returning to repository root...${NC}"
        if [ -n "$GIT_WT_ORIGINAL_DIR" ] && [ -d "$GIT_WT_ORIGINAL_DIR" ]; then
            echo "üìç Back to: $GIT_WT_ORIGINAL_DIR"
            cd "$GIT_WT_ORIGINAL_DIR"
        else
            # Fallback to git root if original dir is not available
            local git_root=$(git rev-parse --show-toplevel 2>/dev/null)
            if [ -n "$git_root" ]; then
                cd "$git_root"
                echo "üìç Back to: $git_root"
            fi
        fi
        echo ""
        echo -e "${GREEN}üí° Type 'exit' to return to your original shell${NC}"
        # Can't exit parent shell from script, user needs to type 'exit'
        return 0
    fi
    return 1
}

setup_worktrees_dir() {
    # Create .worktrees directory if it doesn't exist
    mkdir -p .worktrees
    
    # Add .worktrees to .gitignore if not already there
    if ! grep -q "^\.worktrees/" .gitignore 2>/dev/null; then
        echo ".worktrees/" >> .gitignore
        echo -e "${GREEN}üìù Added .worktrees/ to .gitignore${NC}"
    fi
}

cmd_new() {
    local branch_name="${1:-task-$(date +%Y%m%d-%H%M%S)}"
    local base_branch="${2:-main}"
    local worktree_dir=".worktrees/${branch_name}"
    
    ensure_git_repo
    setup_worktrees_dir
    
    echo -e "${BLUE}üöÄ Creating new worktree...${NC}"
    echo "Branch: $branch_name"
    echo "Base: $base_branch"
    echo "Directory: $worktree_dir"
    
    # Create the worktree in organized structure
    git worktree add -b "$branch_name" "$worktree_dir" "$base_branch"
    
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}‚úÖ Worktree created successfully!${NC}"
        echo -e "${BLUE}üìÇ Directory: $(realpath $worktree_dir)${NC}"
        
        # Create a .git-wt-session file for session management
        echo "branch=$branch_name" > "$worktree_dir/.git-wt-session"
        echo "created=$(date -Iseconds)" >> "$worktree_dir/.git-wt-session"
        echo "base_branch=$base_branch" >> "$worktree_dir/.git-wt-session"
        
        echo ""
        echo "Next steps:"
        echo "1. cd $worktree_dir"
        echo "2. claude code 'your task description'"
        echo ""
        echo "Or use: git wt switch $branch_name"
    else
        echo -e "${RED}‚ùå Failed to create worktree${NC}"
        exit 1
    fi
}

cmd_list() {
    ensure_git_repo
    
    echo -e "${BLUE}üìã Git Worktrees${NC}"
    echo "========================"
    
    if [ ! -d ".worktrees" ]; then
        echo "No .worktrees directory found"
        return 0
    fi
    
    local found_any=false
    for worktree_dir in .worktrees/*/; do
        if [ -d "$worktree_dir" ]; then
            found_any=true
            local branch_name=$(basename "$worktree_dir")
            local relative_path="$worktree_dir"
            
            echo ""
            echo -e "${GREEN}üåø Branch: $branch_name${NC}"
            echo -e "${BLUE}üìÅ Path: $relative_path${NC}"
            
            # Get commit info
            if [ -d "$worktree_dir/.git" ] || [ -f "$worktree_dir/.git" ]; then
                cd "$worktree_dir"
                local commit_info=$(git log -1 --format='%h %s' 2>/dev/null || echo 'No commits')
                echo "üíæ Commit: $commit_info"
                
                # Check session info if available
                if [ -f ".git-wt-session" ]; then
                    local created=$(grep "created=" .git-wt-session | cut -d'=' -f2)
                    local task=$(grep "^task=" .git-wt-session | cut -d'=' -f2-)
                    echo "‚è∞ Created: $created"
                    if [ -n "$task" ]; then
                        echo "üìù Task: $task"
                    fi
                fi
                
                # Check for uncommitted changes
                if ! git diff-index --quiet HEAD 2>/dev/null; then
                    echo -e "${YELLOW}üîÑ Status: Has uncommitted changes${NC}"
                else
                    echo -e "${GREEN}‚úÖ Status: Clean${NC}"
                fi
                cd - > /dev/null
            fi
        fi
    done
    
    if [ "$found_any" != true ]; then
        echo "No worktrees found in .worktrees/"
    fi
}

cmd_switch() {
    local create_shell=false
    local branch_name=""
    
    ensure_git_repo
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -s|--shell)
                create_shell=true
                shift
                ;;
            -*)
                echo -e "${RED}Unknown option: $1${NC}"
                echo "Usage: git wt switch [-s|--shell] <branch-name>"
                return 1
                ;;
            *)
                branch_name="$1"
                break
                ;;
        esac
    done
    
    if [ -z "$branch_name" ]; then
        echo "Available worktrees:"
        cmd_list
        echo ""
        echo "Usage: git wt switch [-s|--shell] <branch-name>"
        return 1
    fi
    
    local worktree_path=".worktrees/$branch_name"
    
    if [ -d "$worktree_path" ]; then
        echo -e "${BLUE}üîÑ Switching to worktree: $branch_name${NC}"
        cd "$worktree_path"
        
        # Show current session info
        if [ -f ".git-wt-session" ]; then
            echo -e "${BLUE}üìã Session info:${NC}"
            cat .git-wt-session
        fi
        
        echo ""
        echo "Current directory: $(pwd)"
        echo "Git status:"
        git status --short
        echo ""
        
        if [ "$create_shell" = true ]; then
            # Start worktree shell
            echo -e "${GREEN}Starting worktree shell. Type 'exit' or use 'git wt root' to return.${NC}"
            export GIT_WT_SHELL=1
            export GIT_WT_ORIGINAL_DIR="$OLDPWD"
            export GIT_WT_BRANCH="$branch_name"
            PS1="(wt:$branch_name) $PS1" $SHELL
        else
            # Just change directory
            echo -e "${GREEN}‚úÖ Ready to work in worktree${NC}"
        fi
    else
        echo -e "${RED}‚ùå Worktree '$branch_name' not found in .worktrees/${NC}"
        echo "Available worktrees:"
        ls -1 .worktrees/ 2>/dev/null || echo "No worktrees found"
        return 1
    fi
}

cmd_resume() {
    local create_shell=false
    local branch_name=""
    
    ensure_git_repo
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -s|--shell)
                create_shell=true
                shift
                ;;
            -*)
                echo -e "${RED}Unknown option: $1${NC}"
                echo "Usage: git wt resume [-s|--shell] <branch-name>"
                return 1
                ;;
            *)
                branch_name="$1"
                break
                ;;
        esac
    done
    
    if [ -z "$branch_name" ]; then
        echo "Available worktrees to resume:"
        ls -1 .worktrees/ 2>/dev/null || echo "No worktrees found"
        echo ""
        echo "Usage: git wt resume [-s|--shell] <branch-name>"
        return 1
    fi
    
    if [ ! -d ".worktrees/$branch_name" ]; then
        echo -e "${RED}‚ùå Worktree '$branch_name' not found${NC}"
        return 1
    fi
    
    cd ".worktrees/$branch_name"
    
    echo -e "${BLUE}üîÑ Resuming work in: $branch_name${NC}"
    
    # Show session info if available
    if [ -f ".git-wt-session" ]; then
        echo -e "${BLUE}üìã Previous session:${NC}"
        cat .git-wt-session | while IFS='=' read key value; do
            case $key in
                task) echo "  Task: $value" ;;
                created) echo "  Created: $value" ;;
                branch) echo "  Branch: $value" ;;
                base_branch) echo "  Base: $value" ;;
            esac
        done
        echo ""
    fi
    
    echo "Current status:"
    git status --short
    echo ""
    echo "Ready to continue work in $(pwd)"
    
    if [ "$create_shell" = true ]; then
        # Start worktree shell
        echo -e "${GREEN}Starting worktree shell. Type 'exit' or use 'git wt root' to return.${NC}"
        export GIT_WT_SHELL=1
        export GIT_WT_ORIGINAL_DIR="$OLDPWD"
        export GIT_WT_BRANCH="$branch_name"
        PS1="(wt:$branch_name) $PS1" $SHELL
    else
        # Just change directory
        echo -e "${GREEN}‚úÖ Ready to continue work in worktree${NC}"
    fi
}

cmd_status() {
    ensure_git_repo
    
    echo -e "${BLUE}üìä Git Worktrees Status${NC}"
    echo "================================"
    
    # Show current location
    echo "üìç Current location: $(pwd)"
    if [[ "$(pwd)" == *".worktrees/"* ]]; then
        echo "   You are currently in a worktree"
    else
        echo "   You are in the main repository"
    fi
    echo ""
    
    # Show all worktrees with detailed status
    cmd_list
    
    echo ""
    echo -e "${BLUE}üìà Summary:${NC}"
    local total_worktrees=$(ls -1d .worktrees/*/ 2>/dev/null | wc -l)
    echo "   Total worktrees: $total_worktrees"
    
    # Count worktrees with changes
    local dirty_count=0
    for worktree_dir in .worktrees/*/; do
        if [ -d "$worktree_dir" ]; then
            cd "$worktree_dir"
            if ! git diff-index --quiet HEAD 2>/dev/null; then
                ((dirty_count++))
            fi
            cd - > /dev/null
        fi
    done
    echo "   With changes: $dirty_count"
    echo "   Clean: $((total_worktrees - dirty_count))"
}

cmd_clean() {
    ensure_git_repo
    
    echo -e "${YELLOW}üßπ Git worktree cleanup${NC}"
    echo ""
    
    if [ ! -d ".worktrees" ]; then
        echo "No .worktrees directory found"
        return 0
    fi
    
    echo "Current worktrees in .worktrees/:"
    cmd_list
    echo ""
    
    # Show merged branches that can be cleaned up
    echo "Branches that have been merged to main:"
    git branch --merged main 2>/dev/null | grep -E "(task-|feature-|fix-)" | sed 's/^[ *]*//' | while read branch; do
        if [ -d ".worktrees/$branch" ]; then
            echo "  üìÅ $branch (in .worktrees/)"
        fi
    done
    echo ""
    
    read -p "Enter branch name to remove (or 'auto' for all merged): " branch_name
    
    if [ "$branch_name" = "auto" ]; then
        # Auto-cleanup merged branches
        git branch --merged main 2>/dev/null | grep -E "(task-|feature-|fix-)" | sed 's/^[ *]*//' | while read branch; do
            if [ "$branch" != "main" ] && [ "$branch" != "master" ] && [ -d ".worktrees/$branch" ]; then
                echo -e "${YELLOW}üóëÔ∏è  Removing worktree for branch: $branch${NC}"
                git worktree remove ".worktrees/$branch" 2>/dev/null || true
                git branch -d "$branch" 2>/dev/null || true
            fi
        done
    elif [ -n "$branch_name" ]; then
        # Remove specific branch
        if [ -d ".worktrees/$branch_name" ]; then
            git worktree remove ".worktrees/$branch_name"
            git branch -d "$branch_name"
            echo -e "${GREEN}‚úÖ Removed worktree: $branch_name${NC}"
        else
            echo -e "${RED}‚ùå Branch $branch_name not found in .worktrees/${NC}"
        fi
    fi
}

cmd_task() {
    local task_description="$1"
    local branch_name="${2:-task-$(date +%Y%m%d-%H%M%S)}"
    
    if [ -z "$task_description" ]; then
        echo "Usage: git wt task 'task description' [branch-name]"
        echo "Example: git wt task 'Add user authentication system' auth-feature"
        exit 1
    fi
    
    ensure_git_repo
    
    # Create the worktree
    cmd_new "$branch_name"
    
    if [ $? -eq 0 ]; then
        # Switch to the new worktree
        cd ".worktrees/$branch_name"
        
        # Save task description to session file
        echo "task=$task_description" >> .git-wt-session
        echo "task_started=$(date -Iseconds)" >> .git-wt-session
        
        echo -e "${BLUE}ü§ñ Starting Claude Code task in worktree...${NC}"
        echo "Task: $task_description"
        echo ""
        
        # Start Claude Code with the task
        claude code "$task_description"
    fi
}

cmd_root() {
    ensure_git_repo
    
    # Check if we're in a worktree shell and exit if so
    if _exit_worktree_shell; then
        return 0
    fi
    
    # Regular root switching logic
    local git_root=$(git rev-parse --show-toplevel)
    
    echo -e "${BLUE}üè† Switching to repository root...${NC}"
    cd "$git_root"
    
    echo "üìç Current directory: $(pwd)"
    echo "üåø Current branch: $(git branch --show-current)"
    echo ""
    
    # Show git status
    echo "Git status:"
    git status --short
    echo ""
    
    # Show available worktrees
    if [ -d ".worktrees" ]; then
        echo -e "${BLUE}üìã Available worktrees:${NC}"
        ls -1 .worktrees/ 2>/dev/null || echo "No worktrees found"
        echo ""
    fi
    
    echo -e "${GREEN}‚úÖ Now in repository root directory${NC}"
}

# =============================================================================
# MAIN COMMAND DISPATCHER
# =============================================================================

case "${1:-help}" in
    "new")
        shift
        cmd_new "$@"
        ;;
    "list"|"ls")
        cmd_list
        ;;
    "switch"|"sw")
        shift
        cmd_switch "$@"
        ;;
    "resume"|"re")
        shift
        cmd_resume "$@"
        ;;
    "root"|"main")
        cmd_root
        ;;
    "status"|"st")
        cmd_status
        ;;
    "clean"|"cleanup")
        cmd_clean
        ;;
    "task"|"tk")
        shift
        cmd_task "$@"
        ;;
    "help"|"-h"|"--help"|*)
        show_help
        ;;
esac
