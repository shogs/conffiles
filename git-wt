#!/bin/bash
# git-wt - Git subcommand for worktree management
# Place this file in your PATH as 'git-wt' (executable)
# Usage: git wt <command> [args...]

# =============================================================================
# GIT WT SUBCOMMAND - Usage: git wt <command>
# =============================================================================

# Colors for output (with detection)
if [[ -t 1 ]] && command -v tput >/dev/null 2>&1 && tput colors >/dev/null 2>&1 && (( $(tput colors) >= 8 )); then
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    BLUE='\033[0;34m'
    NC='\033[0m' # No Color
else
    RED=''
    GREEN=''
    YELLOW=''
    BLUE=''
    NC=''
fi

show_help() {
    echo -e "${BLUE}Git Worktree Management - Usage: git wt <command>${NC}"
    echo ""
    echo -e "${GREEN}üìã Available Commands:${NC}"
    echo -e "  ${BLUE}init${NC} [--template=<name>|--minimal]    - Initialize .git-wt.yaml configuration"
    echo -e "  ${BLUE}new|add${NC} [branch-name] [base-branch]   - Create new worktree"
    echo -e "  ${BLUE}list${NC} [-d]                           - List all worktrees (use -d for details)"
    echo -e "  ${BLUE}switch${NC} [-s|--shell] <branch-name>     - Switch to worktree (optionally start shell)"
    echo -e "  ${BLUE}resume${NC} [-s|--shell] <branch-name>     - Resume work in worktree (optionally start shell)"
    echo -e "  ${BLUE}remove${NC} [-f|--force] <branch-name>     - Remove worktree and branch"
    echo -e "  ${BLUE}root${NC}                                 - Switch to repository root"
    echo -e "  ${BLUE}status${NC}                               - Show overall status"
    echo -e "  ${BLUE}clean${NC}                                - Clean up worktrees"
    echo -e "  ${BLUE}task${NC} 'description' [branch]          - Create worktree + start Claude task"
    echo -e "  ${BLUE}help${NC}                                 - Show this help"
    echo ""
    echo -e "${YELLOW}üì¶ Requirements:${NC}"
    echo -e "  ${BLUE}yq${NC} - YAML processor (required for setup/teardown actions)"
    echo "     Install: brew install yq"
    echo "     Homepage: https://github.com/mikefarah/yq"
    echo ""
    echo -e "${YELLOW}üìÅ Structure: All worktrees are created in .worktrees/ (auto-gitignored)${NC}"
    echo -e "${YELLOW}üîó Integration: Works seamlessly with Claude Code slash commands${NC}"
    echo ""
    echo -e "${GREEN}Examples:${NC}"
    echo "  git wt init                          # Initialize configuration"
    echo "  git wt init --template=nodejs-simple # Use specific template"
    echo "  git wt new auth-feature              # or: git wt add auth-feature"
    echo "  git wt task 'Add JWT authentication'"
    echo "  git wt switch auth-feature           # Lightweight switch"
    echo "  git wt switch -s auth-feature        # Switch with shell"
    echo "  git wt resume -s bug-fix             # Resume with shell"
    echo "  git wt remove auth-feature           # Remove worktree (safe)"
    echo "  git wt remove -f old-feature         # Force remove worktree"
    echo "  git wt root                          # Return to main repo"
    echo "  git wt list"
}

ensure_git_repo() {
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        echo -e "${RED}‚ùå Not in a git repository${NC}"
        exit 1
    fi
}

get_default_branch() {
    # Try to get the default branch from the remote
    local default_branch=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@')

    if [ -n "$default_branch" ]; then
        echo "$default_branch"
        return 0
    fi

    # Fallback: check which of main/master exists locally
    if git show-ref --verify --quiet refs/heads/main; then
        echo "main"
    elif git show-ref --verify --quiet refs/heads/master; then
        echo "master"
    else
        # Last resort: try to guess from current branch
        local current_branch=$(git branch --show-current 2>/dev/null)
        if [ -n "$current_branch" ]; then
            echo "$current_branch"
        else
            # Ultimate fallback
            echo "main"
        fi
    fi
}

_is_in_worktree_shell() {
    [ "$GIT_WT_SHELL" = "1" ]
}

_exit_worktree_shell() {
    if _is_in_worktree_shell; then
        echo -e "${BLUE}üè† Exiting worktree shell and returning to repository root...${NC}"
        if [ -n "$GIT_WT_ORIGINAL_DIR" ] && [ -d "$GIT_WT_ORIGINAL_DIR" ]; then
            echo "üìç Back to: $GIT_WT_ORIGINAL_DIR"
            cd "$GIT_WT_ORIGINAL_DIR"
        else
            # Fallback to git root if original dir is not available
            local git_root=$(git rev-parse --show-toplevel 2>/dev/null)
            if [ -n "$git_root" ]; then
                cd "$git_root"
                echo "üìç Back to: $git_root"
            fi
        fi
        echo ""
        echo -e "${GREEN}üí° Type 'exit' to return to your original shell${NC}"
        # Can't exit parent shell from script, user needs to type 'exit'
        return 0
    fi
    return 1
}

setup_worktrees_dir() {
    # Create .worktrees directory if it doesn't exist
    mkdir -p .worktrees

    # Add .worktrees to .gitignore if not already there
    if ! grep -q "^\.worktrees/" .gitignore 2>/dev/null; then
        echo ".worktrees/" >> .gitignore
        echo -e "${GREEN}üìù Added .worktrees/ to .gitignore${NC}"
    fi
}

require_config() {
    if [ ! -f .git-wt.yaml ]; then
        echo -e "${RED}‚ùå No .git-wt.yaml configuration found!${NC}"
        echo -e "${YELLOW}üí° Run 'git wt init' to create a configuration${NC}"
        echo -e "${YELLOW}üí° Or create .git-wt.yaml manually${NC}"
        echo -e "${YELLOW}üí° See templates/ directory for examples${NC}"
        exit 1
    fi
}

execute_setup_actions() {
    local git_root="$1"
    local worktree_path="$2"
    local worktree_name="$3"
    local base_branch="$4"

    export GIT_ROOT="$git_root"
    export WORKTREE_PATH="$worktree_path"
    export WORKTREE_NAME="$worktree_name"
    export BASE_BRANCH="$base_branch"

    # Save current directory to restore after setup actions
    pushd . > /dev/null

    if ! command -v yq >/dev/null 2>&1; then
        echo -e "${RED}‚ùå yq is required to run YAML-based setup actions${NC}"
        echo -e "${YELLOW}üí° Install yq: brew install yq${NC}"
        echo ""
        echo -e "${BLUE}üì¶ yq is a lightweight YAML processor for bash${NC}"
        echo "   Homepage: https://github.com/mikefarah/yq"
        echo ""
        popd > /dev/null
        exit 1
    fi

    local setup_count=$(yq eval '.setup | length' .git-wt.yaml 2>/dev/null)

    if [ "$setup_count" = "0" ] || [ "$setup_count" = "null" ] || [ -z "$setup_count" ]; then
        echo -e "${BLUE}‚ÑπÔ∏è  No setup actions configured${NC}"
        popd > /dev/null
        return 0
    fi

    echo -e "${BLUE}üîß Running setup actions...${NC}"
    echo ""

    for i in $(seq 0 $((setup_count - 1))); do
        local name=$(yq eval ".setup[$i].name" .git-wt.yaml)
        local desc=$(yq eval ".setup[$i].description" .git-wt.yaml)
        local script=$(yq eval ".setup[$i].script" .git-wt.yaml)

        echo -e "${GREEN}‚ñ∂ $desc${NC}"

        # Run script in subshell so 'exit' doesn't terminate main process
        (eval "$script")
        local exit_code=$?

        if [ $exit_code -eq 1 ]; then
            echo -e "${RED}‚ùå Setup action '$name' failed${NC}"
            popd > /dev/null
            return 1
        fi

        echo ""
    done

    echo -e "${GREEN}‚úÖ Setup actions completed${NC}"
    popd > /dev/null
    return 0
}

execute_teardown_actions() {
    local git_root="$1"
    local worktree_path="$2"
    local worktree_name="$3"

    export GIT_ROOT="$git_root"
    export WORKTREE_PATH="$worktree_path"
    export WORKTREE_NAME="$worktree_name"

    # Save current directory to restore after teardown actions
    pushd . > /dev/null

    if ! command -v yq >/dev/null 2>&1; then
        # For teardown, we're lenient - just skip if yq not available
        echo -e "${YELLOW}‚ö†Ô∏è  yq not available, skipping teardown actions${NC}"
        echo -e "${YELLOW}üí° Install yq: brew install yq${NC}"
        popd > /dev/null
        return 0
    fi

    local teardown_count=$(yq eval '.teardown | length' .git-wt.yaml 2>/dev/null)

    if [ "$teardown_count" = "0" ] || [ "$teardown_count" = "null" ] || [ -z "$teardown_count" ]; then
        popd > /dev/null
        return 0
    fi

    echo -e "${BLUE}üîß Running teardown actions...${NC}"
    echo ""

    for i in $(seq 0 $((teardown_count - 1))); do
        local name=$(yq eval ".teardown[$i].name" .git-wt.yaml)
        local desc=$(yq eval ".teardown[$i].description" .git-wt.yaml)
        local script=$(yq eval ".teardown[$i].script" .git-wt.yaml)

        echo -e "${YELLOW}‚ñ∂ $desc${NC}"

        # Run script in subshell so 'exit' doesn't terminate main process
        (eval "$script")

        echo ""
    done

    popd > /dev/null
    return 0
}

cmd_init() {
    local template=""
    local auto_detect=true

    while [[ $# -gt 0 ]]; do
        case $1 in
            --template=*)
                template="${1#*=}"
                auto_detect=false
                shift
                ;;
            --minimal)
                template="minimal"
                auto_detect=false
                shift
                ;;
            -h|--help)
                echo "Usage: git wt init [--template=<name>|--minimal]"
                echo ""
                echo "Available templates:"
                echo "  nodejs-full     - Node.js with full setup (current git-wt behavior)"
                echo "  nodejs-simple   - Node.js with simple npm install"
                echo "  python-django   - Python Django projects"
                echo "  minimal         - No setup actions"
                echo ""
                echo "Without --template, auto-detects project type"
                return 0
                ;;
            *)
                echo -e "${RED}Unknown option: $1${NC}"
                return 1
                ;;
        esac
    done

    ensure_git_repo

    if [ -f .git-wt.yaml ]; then
        echo -e "${YELLOW}‚ö†Ô∏è  .git-wt.yaml already exists${NC}"
        echo -n "Overwrite? [y/N]: "
        read -n 1 -r response
        echo

        case $response in
            [yY])
                echo "Proceeding with overwrite..."
                ;;
            *)
                echo "Cancelled"
                return 0
                ;;
        esac
    fi

    if [ "$auto_detect" = true ]; then
        if [ -f package.json ]; then
            template="nodejs-full"
            echo -e "${BLUE}üîç Detected Node.js project${NC}"
        elif [ -f requirements.txt ] || [ -f setup.py ]; then
            template="python-django"
            echo -e "${BLUE}üîç Detected Python project${NC}"
        else
            template="minimal"
            echo -e "${BLUE}üîç No specific project type detected, using minimal template${NC}"
        fi
    fi

    # Get the directory where the actual script lives (follow symlinks)
    local script_path="${BASH_SOURCE[0]}"
    # Resolve symlink if this script is symlinked
    if [ -L "$script_path" ]; then
        script_path="$(readlink "$script_path")"
    fi
    local script_dir="$(cd "$(dirname "$script_path")" && pwd)"
    local template_file="$script_dir/templates/${template}.yaml"

    if [ ! -f "$template_file" ]; then
        echo -e "${RED}‚ùå Template '$template' not found${NC}"
        echo -e "${YELLOW}üí° Available templates:${NC}"
        ls -1 "$script_dir/templates/" 2>/dev/null | sed 's/\.yaml$//' | sed 's/^/  /'
        return 1
    fi

    cp "$template_file" .git-wt.yaml

    echo -e "${GREEN}‚úÖ Created .git-wt.yaml from '$template' template${NC}"
    echo ""
    echo -e "${BLUE}üìù Next steps:${NC}"
    echo "  1. Review and customize .git-wt.yaml as needed"
    echo "  2. Consider adding .git-wt.yaml to git to share with team"
    echo "  3. Run 'git wt new <branch-name>' to create your first worktree"
    echo ""
    echo -n "Add .git-wt.yaml to git? [Y/n]: "
    read -n 1 -r response
    echo

    case $response in
        [nN])
            echo "Skipped git add"
            ;;
        *)
            git add .git-wt.yaml
            echo -e "${GREEN}‚úÖ Added .git-wt.yaml to git${NC}"
            echo -e "${YELLOW}üí° Don't forget to commit: git commit -m 'Add git-wt configuration'${NC}"
            ;;
    esac
}

cmd_new() {
    local branch_name=""
    local base_branch=$(get_default_branch)

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -*)
                echo -e "${RED}Unknown option: $1${NC}"
                echo "Usage: git wt new [branch-name] [base-branch]"
                return 1
                ;;
            *)
                if [ -z "$branch_name" ]; then
                    branch_name="$1"
                else
                    base_branch="$1"
                fi
                shift
                ;;
        esac
    done

    # Set default branch name if not provided
    if [ -z "$branch_name" ]; then
        branch_name="task-$(date +%Y%m%d-%H%M%S)"
    fi

    local git_root=$(git rev-parse --show-toplevel)
    local worktree_dir="$git_root/.worktrees/${branch_name}"

    ensure_git_repo
    require_config
    setup_worktrees_dir

    echo -e "${BLUE}üöÄ Creating new worktree...${NC}"
    echo "Branch: $branch_name"
    echo "Base: $base_branch"
    echo "Directory: $worktree_dir"

    # Create the worktree in organized structure
    git worktree add -b "$branch_name" "$worktree_dir" "$base_branch"

    if [ $? -eq 0 ]; then
        echo -e "${GREEN}‚úÖ Worktree created successfully!${NC}"
        echo -e "${BLUE}üìÇ Directory: $(realpath $worktree_dir)${NC}"

        # Create a .git-wt-session file for session management
        echo "branch=$branch_name" > "$worktree_dir/.git-wt-session"
        echo "created=$(date -Iseconds)" >> "$worktree_dir/.git-wt-session"
        echo "base_branch=$base_branch" >> "$worktree_dir/.git-wt-session"

        echo ""

        # Execute setup actions from YAML configuration
        cd "$git_root"
        if ! execute_setup_actions "$git_root" "$worktree_dir" "$branch_name" "$base_branch"; then
            echo -e "${RED}‚ùå Setup actions failed${NC}"
            echo -e "${YELLOW}‚ö†Ô∏è  Worktree was created but setup failed${NC}"
            echo -e "${YELLOW}üí° You may want to remove it: git wt remove $branch_name${NC}"
            return 1
        fi

        echo ""
        echo -e "${GREEN}‚úÖ Worktree created successfully!${NC}"
        echo ""

        # Ask if user wants to switch to the new worktree
        echo -n "Switch to the new worktree with shell? [Y/n]: "
        read -n 1 -r response
        echo  # Add newline after single character input

        case $response in
            [nN][oO]|[nN])
                echo -e "${BLUE}üìã Worktree ready for use${NC}"
                echo ""
                echo "Next steps:"
                echo "1. cd $worktree_dir"
                echo "2. Your worktree is ready to use"
                echo "3. Use: claude code 'your task description'"
                echo ""
                echo "Or use: git wt switch -s $branch_name"
                ;;
            *)
                # Default to yes (Y or Enter or anything else)
                echo -e "${BLUE}üîÑ Switching to worktree with shell...${NC}"
                echo ""
                # Call the existing switch function with shell option
                cmd_switch -s "$branch_name"
                ;;
        esac
    else
        echo -e "${RED}‚ùå Failed to create worktree${NC}"
        exit 1
    fi
}

cmd_list() {
    local show_details=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -d|--details)
                show_details=true
                shift
                ;;
            -*)
                echo -e "${RED}Unknown option: $1${NC}"
                echo "Usage: git wt list [-d|--details]"
                return 1
                ;;
            *)
                echo -e "${RED}Unexpected argument: $1${NC}"
                echo "Usage: git wt list [-d|--details]"
                return 1
                ;;
        esac
    done

    ensure_git_repo

    if [ ! -d ".worktrees" ]; then
        echo "No .worktrees directory found"
        return 0
    fi

    if [ "$show_details" = true ]; then
        # Show detailed output (original format)
        echo -e "${BLUE}üìã Git Worktrees${NC}"
        echo "========================"

        local found_any=false
        for worktree_dir in .worktrees/*/; do
            if [ -d "$worktree_dir" ]; then
                found_any=true
                local branch_name=$(basename "$worktree_dir")
                local relative_path="$worktree_dir"

                echo ""
                echo -e "${GREEN}üåø Branch: $branch_name${NC}"
                echo -e "${BLUE}üìÅ Path: $relative_path${NC}"

                # Get commit info
                if [ -d "$worktree_dir/.git" ] || [ -f "$worktree_dir/.git" ]; then
                    cd "$worktree_dir"
                    local commit_info=$(git log -1 --format='%h %s' 2>/dev/null || echo 'No commits')
                    echo "üíæ Commit: $commit_info"

                    # Check session info if available
                    if [ -f ".git-wt-session" ]; then
                        local created=$(grep "created=" .git-wt-session | cut -d'=' -f2)
                        local task=$(grep "^task=" .git-wt-session | cut -d'=' -f2-)
                        echo "‚è∞ Created: $created"
                        if [ -n "$task" ]; then
                            echo "üìù Task: $task"
                        fi
                    fi

                    # Check for uncommitted changes and untracked files
                    local git_status=$(git status --porcelain 2>/dev/null)
                    if [ -n "$git_status" ]; then
                        echo -e "${YELLOW}üîÑ Status: Has uncommitted changes${NC}"
                    else
                        echo -e "${GREEN}‚úÖ Status: Clean${NC}"
                    fi
                    cd - > /dev/null
                fi
            fi
        done

        if [ "$found_any" != true ]; then
            echo "No worktrees found in .worktrees/"
        fi
    else
        # Show simplified output (branch, status)
        echo -e "${BLUE}üìã Git Worktrees${NC}"
        echo "========================"
        echo ""

        local found_any=false
        for worktree_dir in .worktrees/*/; do
            if [ -d "$worktree_dir" ]; then
                found_any=true
                local branch_name=$(basename "$worktree_dir")
                local status="Unknown"
                local status_color=""

                # Get status
                if [ -d "$worktree_dir/.git" ] || [ -f "$worktree_dir/.git" ]; then
                    cd "$worktree_dir"
                    # Check for both modified and untracked files
                    local git_status=$(git status --porcelain 2>/dev/null)
                    if [ -n "$git_status" ]; then
                        status="Modified"
                        status_color="${YELLOW}"
                    else
                        status="Clean"
                        status_color="${GREEN}"
                    fi
                    cd - > /dev/null
                fi

                echo -e "${GREEN}üåø ${branch_name}${NC} - ${status_color}${status}${NC}"
            fi
        done

        if [ "$found_any" != true ]; then
            echo "No worktrees found in .worktrees/"
        fi
    fi
}

cmd_switch() {
    local create_shell=false
    local branch_name=""

    ensure_git_repo

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -s|--shell)
                create_shell=true
                shift
                ;;
            -*)
                echo -e "${RED}Unknown option: $1${NC}"
                echo "Usage: git wt switch [-s|--shell] <branch-name>"
                return 1
                ;;
            *)
                branch_name="$1"
                break
                ;;
        esac
    done

    if [ -z "$branch_name" ]; then
        echo "Available worktrees:"
        cmd_list
        echo ""
        echo "Usage: git wt switch [-s|--shell] <branch-name>"
        return 1
    fi

    # Get git root before changing directories
    local git_root=$(git rev-parse --show-toplevel)
    local worktree_path="$git_root/.worktrees/$branch_name"

    if [ -d "$worktree_path" ]; then
        echo -e "${BLUE}üîÑ Switching to worktree: $branch_name${NC}"
        cd "$worktree_path"

        # Show current session info
        if [ -f ".git-wt-session" ]; then
            echo -e "${BLUE}üìã Session info:${NC}"
            cat .git-wt-session
        fi

        echo ""
        echo "Current directory: $(pwd)"
        echo "Git status:"
        git status --short
        echo ""

        if [ "$create_shell" = true ]; then
            # Start worktree shell
            echo ""
            echo -e "${GREEN}Starting worktree shell. Type 'exit' or use 'git wt root' to return.${NC}"
            export GIT_WT_SHELL=1
            export GIT_WT_ORIGINAL_DIR="$OLDPWD"
            export GIT_WT_BRANCH="$branch_name"
            PS1="(wt:$branch_name) $PS1" $SHELL
        else
            # Just change directory
            echo -e "${GREEN}‚úÖ Ready to work in worktree${NC}"
        fi
    else
        echo -e "${RED}‚ùå Worktree '$branch_name' not found in .worktrees/${NC}"
        echo "Available worktrees:"
        ls -1 .worktrees/ 2>/dev/null || echo "No worktrees found"
        return 1
    fi
}

cmd_resume() {
    local create_shell=false
    local branch_name=""

    ensure_git_repo

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -s|--shell)
                create_shell=true
                shift
                ;;
            -*)
                echo -e "${RED}Unknown option: $1${NC}"
                echo "Usage: git wt resume [-s|--shell] <branch-name>"
                return 1
                ;;
            *)
                branch_name="$1"
                break
                ;;
        esac
    done

    if [ -z "$branch_name" ]; then
        echo "Available worktrees to resume:"
        ls -1 .worktrees/ 2>/dev/null || echo "No worktrees found"
        echo ""
        echo "Usage: git wt resume [-s|--shell] <branch-name>"
        return 1
    fi

    if [ ! -d ".worktrees/$branch_name" ]; then
        echo -e "${RED}‚ùå Worktree '$branch_name' not found${NC}"
        return 1
    fi

    # Get git root before changing directories
    local git_root=$(git rev-parse --show-toplevel)

    cd ".worktrees/$branch_name"

    echo -e "${BLUE}üîÑ Resuming work in: $branch_name${NC}"

    # Show session info if available
    if [ -f ".git-wt-session" ]; then
        echo -e "${BLUE}üìã Previous session:${NC}"
        cat .git-wt-session | while IFS='=' read key value; do
            case $key in
                task) echo "  Task: $value" ;;
                created) echo "  Created: $value" ;;
                branch) echo "  Branch: $value" ;;
                base_branch) echo "  Base: $value" ;;
            esac
        done
        echo ""
    fi

    echo "Current status:"
    git status --short
    echo ""
    echo "Ready to continue work in $(pwd)"

    if [ "$create_shell" = true ]; then
        # Start worktree shell
        echo ""
        echo -e "${GREEN}Starting worktree shell. Type 'exit' or use 'git wt root' to return.${NC}"
        export GIT_WT_SHELL=1
        export GIT_WT_ORIGINAL_DIR="$OLDPWD"
        export GIT_WT_BRANCH="$branch_name"
        PS1="(wt:$branch_name) $PS1" $SHELL
    else
        # Just change directory
        echo -e "${GREEN}‚úÖ Ready to continue work in worktree${NC}"
    fi
}

cmd_status() {
    ensure_git_repo

    echo -e "${BLUE}üìä Git Worktrees Status${NC}"
    echo "================================"

    # Show current location
    echo "üìç Current location: $(pwd)"
    if [[ "$(pwd)" == *".worktrees/"* ]]; then
        echo "   You are currently in a worktree"
    else
        echo "   You are in the main repository"
    fi
    echo ""

    # Show all worktrees with detailed status
    cmd_list

    echo ""
    echo -e "${BLUE}üìà Summary:${NC}"
    local total_worktrees=$(ls -1d .worktrees/*/ 2>/dev/null | wc -l)
    echo "   Total worktrees: $total_worktrees"

    # Count worktrees with changes
    local dirty_count=0
    for worktree_dir in .worktrees/*/; do
        if [ -d "$worktree_dir" ]; then
            cd "$worktree_dir"
            local git_status=$(git status --porcelain 2>/dev/null)
            if [ -n "$git_status" ]; then
                ((dirty_count++))
            fi
            cd - > /dev/null
        fi
    done
    echo "   With changes: $dirty_count"
    echo "   Clean: $((total_worktrees - dirty_count))"
}

cmd_clean() {
    ensure_git_repo

    echo -e "${YELLOW}üßπ Git worktree cleanup${NC}"
    echo ""

    if [ ! -d ".worktrees" ]; then
        echo "No .worktrees directory found"
        return 0
    fi

    echo "Current worktrees in .worktrees/:"
    cmd_list
    echo ""

    # Show merged branches that can be cleaned up
    local default_branch=$(get_default_branch)
    echo "Branches that have been merged to $default_branch:"
    git branch --merged "$default_branch" 2>/dev/null | grep -E "(task-|feature-|fix-)" | sed 's/^[ *]*//' | while read branch; do
        if [ -d ".worktrees/$branch" ]; then
            echo "  üìÅ $branch (in .worktrees/)"
        fi
    done
    echo ""

    read -p "Enter branch name to remove (or 'auto' for all merged): " branch_name

    if [ "$branch_name" = "auto" ]; then
        # Auto-cleanup merged branches
        local default_branch=$(get_default_branch)
        git branch --merged "$default_branch" 2>/dev/null | grep -E "(task-|feature-|fix-)" | sed 's/^[ *]*//' | while read branch; do
            if [ "$branch" != "main" ] && [ "$branch" != "master" ] && [ -d ".worktrees/$branch" ]; then
                echo -e "${YELLOW}üóëÔ∏è  Removing worktree for branch: $branch${NC}"
                git worktree remove ".worktrees/$branch" 2>/dev/null || true
                git branch -d "$branch" 2>/dev/null || true
            fi
        done
    elif [ -n "$branch_name" ]; then
        # Remove specific branch
        if [ -d ".worktrees/$branch_name" ]; then
            git worktree remove ".worktrees/$branch_name"
            git branch -d "$branch_name"
            echo -e "${GREEN}‚úÖ Removed worktree: $branch_name${NC}"
        else
            echo -e "${RED}‚ùå Branch $branch_name not found in .worktrees/${NC}"
        fi
    fi
}

cmd_task() {
    local task_description="$1"
    local branch_name="${2:-task-$(date +%Y%m%d-%H%M%S)}"

    if [ -z "$task_description" ]; then
        echo "Usage: git wt task 'task description' [branch-name]"
        echo "Example: git wt task 'Add user authentication system' auth-feature"
        exit 1
    fi

    ensure_git_repo

    # Create the worktree
    cmd_new "$branch_name"

    if [ $? -eq 0 ]; then
        # Switch to the new worktree
        cd ".worktrees/$branch_name"

        # Save task description to session file
        echo "task=$task_description" >> .git-wt-session
        echo "task_started=$(date -Iseconds)" >> .git-wt-session

        echo -e "${BLUE}ü§ñ Starting Claude Code task in worktree...${NC}"
        echo "Task: $task_description"
        echo ""

        # Start Claude Code with the task
        claude code "$task_description"
    fi
}

cmd_remove() {
    local force_remove=false
    local branch_name=""

    ensure_git_repo

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -f|--force)
                force_remove=true
                shift
                ;;
            -*)
                echo -e "${RED}Unknown option: $1${NC}"
                echo "Usage: git wt remove [-f|--force] <branch-name>"
                return 1
                ;;
            *)
                branch_name="$1"
                break
                ;;
        esac
    done

    if [ -z "$branch_name" ]; then
        echo "Available worktrees to remove:"
        cmd_list
        echo ""
        echo "Usage: git wt remove [-f|--force] <branch-name>"
        return 1
    fi

    local git_root=$(git rev-parse --show-toplevel)
    local worktree_path="$git_root/.worktrees/$branch_name"

    if [ ! -d "$worktree_path" ]; then
        echo -e "${RED}‚ùå Worktree '$branch_name' not found in .worktrees/${NC}"
        echo "Available worktrees:"
        ls -1 .worktrees/ 2>/dev/null || echo "No worktrees found"
        return 1
    fi

    # Check if currently in the worktree we're trying to remove
    if _is_in_worktree_shell && [ "$GIT_WT_BRANCH" = "$branch_name" ]; then
        echo -e "${RED}‚ùå Cannot remove worktree '$branch_name' - you are currently in its shell${NC}"
        echo -e "${YELLOW}üí° Use 'git wt root' to exit the worktree shell first${NC}"
        return 1
    fi

    # Check for uncommitted changes unless force flag is used
    if [ "$force_remove" != true ]; then
        cd "$worktree_path"
        local git_status=$(git status --porcelain 2>/dev/null)
        if [ -n "$git_status" ]; then
            echo -e "${RED}‚ùå Cannot remove worktree '$branch_name' - has uncommitted changes:${NC}"
            echo ""
            git status --short
            echo ""
            echo -e "${YELLOW}üí° Use 'git wt remove -f $branch_name' to force removal${NC}"
            cd - > /dev/null
            return 1
        fi
        cd - > /dev/null
    fi

    # Execute teardown actions before removing worktree
    cd "$git_root"
    execute_teardown_actions "$git_root" "$worktree_path" "$branch_name"

    # Ensure we're back in git root and not in the worktree we're about to remove
    cd "$git_root"

    # Double-check we're not inside the worktree path
    local current_dir=$(pwd)
    if [[ "$current_dir" == "$worktree_path"* ]]; then
        echo -e "${RED}‚ùå Cannot remove worktree - still inside it: $current_dir${NC}"
        echo -e "${YELLOW}üí° Changing to git root: $git_root${NC}"
        cd "$git_root"
    fi

    echo -e "${YELLOW}üóëÔ∏è  Removing worktree: $branch_name${NC}"
    echo "   Current directory: $(pwd)"
    echo "   Worktree path: $worktree_path"

    # Remove the worktree
    local remove_output=$(git worktree remove "$worktree_path" --force 2>&1)
    local remove_exit_code=$?

    if [ $remove_exit_code -eq 0 ]; then
        echo -e "${GREEN}‚úÖ Worktree removed successfully${NC}"

        # Delete the branch
        if git show-ref --verify --quiet "refs/heads/$branch_name"; then
            if [ "$force_remove" = true ]; then
                git branch -D "$branch_name" 2>/dev/null
                if [ $? -eq 0 ]; then
                    echo -e "${GREEN}‚úÖ Branch '$branch_name' deleted (forced)${NC}"
                else
                    echo -e "${YELLOW}‚ö†Ô∏è  Failed to delete branch '$branch_name'${NC}"
                fi
            else
                git branch -d "$branch_name" 2>/dev/null
                if [ $? -eq 0 ]; then
                    echo -e "${GREEN}‚úÖ Branch '$branch_name' deleted${NC}"
                else
                    echo -e "${YELLOW}‚ö†Ô∏è  Branch '$branch_name' not deleted - may have unmerged commits${NC}"
                    echo -e "${YELLOW}üí° Use 'git branch -D $branch_name' to force delete${NC}"
                fi
            fi
        else
            echo -e "${YELLOW}‚ö†Ô∏è  Branch '$branch_name' not found or already deleted${NC}"
        fi

        echo ""
        echo -e "${BLUE}üìä Remaining worktrees:${NC}"
        cmd_list
    else
        echo -e "${RED}‚ùå Failed to remove worktree${NC}"
        echo "   Error output: $remove_output"
        echo "   Exit code: $remove_exit_code"
        return 1
    fi
}

cmd_root() {
    ensure_git_repo

    # Check if we're in a worktree shell and exit if so
    if _exit_worktree_shell; then
        return 0
    fi

    # Regular root switching logic
    local git_root=$(git rev-parse --show-toplevel)

    echo -e "${BLUE}üè† Switching to repository root...${NC}"
    cd "$git_root"

    echo "üìç Current directory: $(pwd)"
    echo "üåø Current branch: $(git branch --show-current)"
    echo ""

    # Show git status
    echo "Git status:"
    git status --short
    echo ""

    # Show available worktrees
    if [ -d ".worktrees" ]; then
        echo -e "${BLUE}üìã Available worktrees:${NC}"
        ls -1 .worktrees/ 2>/dev/null || echo "No worktrees found"
        echo ""
    fi

    echo -e "${GREEN}‚úÖ Now in repository root directory${NC}"
}

# =============================================================================
# MAIN COMMAND DISPATCHER
# =============================================================================

case "${1:-help}" in
    "init")
        shift
        cmd_init "$@"
        ;;
    "new"|"add")
        shift
        cmd_new "$@"
        ;;
    "list"|"ls")
        shift
        cmd_list "$@"
        ;;
    "switch"|"sw")
        shift
        cmd_switch "$@"
        ;;
    "resume"|"re")
        shift
        cmd_resume "$@"
        ;;
    "remove"|"rm")
        shift
        cmd_remove "$@"
        ;;
    "root"|"main")
        cmd_root
        ;;
    "status"|"st")
        cmd_status
        ;;
    "clean"|"cleanup")
        cmd_clean
        ;;
    "task"|"tk")
        shift
        cmd_task "$@"
        ;;
    "help"|"-h"|"--help"|*)
        show_help
        ;;
esac
