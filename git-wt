#!/bin/bash
# git-wt - Git subcommand for worktree management
# Place this file in your PATH as 'git-wt' (executable)
# Usage: git wt <command> [args...]

# =============================================================================
# GIT WT SUBCOMMAND - Usage: git wt <command>
# =============================================================================

# Colors for output (with detection)
if [[ -t 1 ]] && command -v tput >/dev/null 2>&1 && tput colors >/dev/null 2>&1 && (( $(tput colors) >= 8 )); then
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    BLUE='\033[0;34m'
    NC='\033[0m' # No Color
else
    RED=''
    GREEN=''
    YELLOW=''
    BLUE=''
    NC=''
fi

show_help() {
    echo -e "${BLUE}Git Worktree Management - Usage: git wt <command>${NC}"
    echo ""
    echo -e "${GREEN}üìã Available Commands:${NC}"
    echo -e "  ${BLUE}new|add${NC} [branch-name] [base-branch]    - Create new worktree"
    echo -e "  ${BLUE}list${NC} [-d]                           - List all worktrees (use -d for details)" 
    echo -e "  ${BLUE}switch${NC} [-s|--shell] <branch-name>     - Switch to worktree (optionally start shell)"
    echo -e "  ${BLUE}resume${NC} [-s|--shell] <branch-name>     - Resume work in worktree (optionally start shell)"
    echo -e "  ${BLUE}remove${NC} [-f|--force] <branch-name>     - Remove worktree and branch"
    echo -e "  ${BLUE}root${NC}                                 - Switch to repository root"
    echo -e "  ${BLUE}status${NC}                               - Show overall status"
    echo -e "  ${BLUE}clean${NC}                                - Clean up worktrees"
    echo -e "  ${BLUE}task${NC} 'description' [branch]          - Create worktree + start Claude task"
    echo -e "  ${BLUE}help${NC}                                 - Show this help"
    echo ""
    echo -e "${YELLOW}üìÅ Structure: All worktrees are created in .worktrees/ (auto-gitignored)${NC}"
    echo -e "${YELLOW}üîó Integration: Works seamlessly with Claude Code slash commands${NC}"
    echo ""
    echo -e "${GREEN}Examples:${NC}"
    echo "  git wt new auth-feature              # or: git wt add auth-feature"
    echo "  git wt task 'Add JWT authentication'"
    echo "  git wt switch auth-feature           # Lightweight switch"
    echo "  git wt switch -s auth-feature        # Switch with shell"
    echo "  git wt resume -s bug-fix             # Resume with shell"
    echo "  git wt remove auth-feature           # Remove worktree (safe)"
    echo "  git wt remove -f old-feature         # Force remove worktree"
    echo "  git wt root                          # Return to main repo"
    echo "  git wt list"
}

ensure_git_repo() {
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        echo -e "${RED}‚ùå Not in a git repository${NC}"
        exit 1
    fi
}

_is_in_worktree_shell() {
    [ "$GIT_WT_SHELL" = "1" ]
}

_exit_worktree_shell() {
    if _is_in_worktree_shell; then
        echo -e "${BLUE}üè† Exiting worktree shell and returning to repository root...${NC}"
        if [ -n "$GIT_WT_ORIGINAL_DIR" ] && [ -d "$GIT_WT_ORIGINAL_DIR" ]; then
            echo "üìç Back to: $GIT_WT_ORIGINAL_DIR"
            cd "$GIT_WT_ORIGINAL_DIR"
        else
            # Fallback to git root if original dir is not available
            local git_root=$(git rev-parse --show-toplevel 2>/dev/null)
            if [ -n "$git_root" ]; then
                cd "$git_root"
                echo "üìç Back to: $git_root"
            fi
        fi
        echo ""
        echo -e "${GREEN}üí° Type 'exit' to return to your original shell${NC}"
        # Can't exit parent shell from script, user needs to type 'exit'
        return 0
    fi
    return 1
}

_modify_database_url() {
    local env_file="$1"
    local worktree_name="$2"
    
    if [ ! -f "$env_file" ]; then
        return 0
    fi
    
    if grep -q "^DATABASE_URL=\|^DIRECT_URL=" "$env_file"; then
        # Create temporary file for processing
        local temp_file=$(mktemp)
        
        while IFS= read -r line; do
            if [[ $line =~ ^DATABASE_URL= ]] || [[ $line =~ ^DIRECT_URL= ]]; then
                # Extract the URL value
                local url_value="${line#*=}"
                url_value="${url_value%\"}"  # Remove trailing quote
                url_value="${url_value#\"}"  # Remove leading quote
                local var_name="${line%%=*}"
                
                # Modify based on database type
                case $url_value in
                    postgresql://*|postgres://*)
                        # postgresql://user:pass@host:port/dbname -> dbname-worktree
                        modified_url=$(echo "$url_value" | sed "s|\(/[^/?]*\)$|\1-${worktree_name}|")
                        ;;
                    mysql://*)
                        # mysql://user:pass@host:port/dbname -> dbname-worktree
                        modified_url=$(echo "$url_value" | sed "s|\(/[^/?]*\)$|\1-${worktree_name}|")
                        ;;
                    sqlite:*)
                        # sqlite:./file.db -> ./file-worktree.db
                        modified_url=$(echo "$url_value" | sed "s|\(.*\)\(\.db\)|\1-${worktree_name}\2|")
                        ;;
                    *)
                        # Default: try to add suffix before query params or at end
                        modified_url=$(echo "$url_value" | sed "s|\([^?]*\)\([?].*\)\?$|\1-${worktree_name}\2|")
                        ;;
                esac
                
                echo "${var_name}=\"$modified_url\"" >> "$temp_file"
                echo -e "${GREEN}üìù Modified ${var_name} for worktree: ${worktree_name}${NC}"
            else
                echo "$line" >> "$temp_file"
            fi
        done < "$env_file"
        
        # Replace original file
        mv "$temp_file" "$env_file"
    fi
}

_prompt_copy_node_modules() {
    local worktree_path="$1"
    local git_root="$2"
    local copy_all_remaining="$3"  # Pass by reference simulation
    
    # Find all node_modules directories, excluding worktrees and hidden dirs
    local node_modules_dirs=()
    
    while IFS= read -r -d '' dir; do
        # Skip if already exists in worktree
        local relative_path="${dir#$git_root/}"
        local target_path="$worktree_path/$relative_path"
        if [ ! -d "$target_path" ]; then
            node_modules_dirs+=("$dir")
        fi
    done < <(find "$git_root" -name "node_modules" -type d -not -path "*/.worktrees/*" -not -path "*/.*" -not -path "*/node_modules/*/node_modules" -print0)
    
    if [ ${#node_modules_dirs[@]} -eq 0 ]; then
        return 1  # No node_modules to copy
    fi
    
    echo -e "${YELLOW}üì¶ Found ${#node_modules_dirs[@]} node_modules directories:${NC}"
    for dir in "${node_modules_dirs[@]}"; do
        local relative_path="${dir#$git_root/}"
        echo "  ‚Ä¢ $relative_path"
    done
    echo ""
    
    local copy_list=()
    local skip_all=false
    
    for dir in "${node_modules_dirs[@]}"; do
        if [ "$skip_all" = true ]; then
            break
        fi
        
        local relative_path="${dir#$git_root/}"
        local target_path="$worktree_path/$relative_path"
        
        if [ "$copy_all_remaining" = "true" ]; then
            copy_list+=("$dir:$target_path")
            continue
        fi
        
        echo -n "Copy $relative_path? [Y/y/n/q] (Y=all, y=this, n=skip, q=quit): "
        read -r response
        
        case $response in
            [Y]|"")
                # Yes to all remaining (default on enter)
                copy_list+=("$dir:$target_path")
                copy_all_remaining="true"
                # Add all remaining directories
                for remaining_dir in "${node_modules_dirs[@]}"; do
                    if [[ ! " ${copy_list[*]} " =~ " ${remaining_dir}: " ]]; then
                        local remaining_relative="${remaining_dir#$git_root/}"
                        local remaining_target="$worktree_path/$remaining_relative"
                        copy_list+=("$remaining_dir:$remaining_target")
                    fi
                done
                break
                ;;
            [yY][eE][sS]|[yY])
                # Yes to this one
                copy_list+=("$dir:$target_path")
                ;;
            [nN][oO]|[nN])
                # Skip this one
                echo -e "${BLUE}‚è≠Ô∏è  Skipping $relative_path${NC}"
                ;;
            [qQ][uU][iI][tT]|[qQ])
                # Quit copying
                skip_all=true
                echo -e "${BLUE}‚è≠Ô∏è  Quitting node_modules copying${NC}"
                break
                ;;
        esac
    done
    
    if [ ${#copy_list[@]} -eq 0 ]; then
        echo -e "${BLUE}‚è≠Ô∏è  No node_modules selected for copying${NC}"
        return 1
    fi
    
    # Export the copy list for the copy function
    printf '%s\n' "${copy_list[@]}" > /tmp/git-wt-copy-list.$$
    return 0
}

_copy_node_modules() {
    # Read the copy list from temp file
    local copy_list_file="/tmp/git-wt-copy-list.$$"
    
    if [ ! -f "$copy_list_file" ]; then
        echo -e "${RED}‚ùå No copy list found${NC}"
        return 1
    fi
    
    local copy_pairs=()
    while IFS= read -r line; do
        copy_pairs+=("$line")
    done < "$copy_list_file"
    
    # Clean up temp file
    rm -f "$copy_list_file"
    
    if [ ${#copy_pairs[@]} -eq 0 ]; then
        echo -e "${BLUE}‚è≠Ô∏è  No directories to copy${NC}"
        return 0
    fi
    
    echo -e "${BLUE}üìã Copying ${#copy_pairs[@]} node_modules directories...${NC}"
    
    local total_copied=0
    local total_failed=0
    
    for pair in "${copy_pairs[@]}"; do
        local source="${pair%:*}"
        local destination="${pair#*:}"
        local relative_path="${source#$(git rev-parse --show-toplevel)/}"
        
        echo -e "${BLUE}üì¶ Copying $relative_path...${NC}"
        
        # Create parent directory if needed
        mkdir -p "$(dirname "$destination")"
        
        if command -v rsync >/dev/null 2>&1; then
            # Count files for this directory
            local dir_files=$(find "$source" -type f | wc -l | tr -d ' ')
            echo "   üìä $dir_files files to copy..."
            
            # Use rsync with minimal output, show progress via file count
            rsync -a "$source/" "$destination/" &
            local rsync_pid=$!
            
            # Show progress while rsync runs
            while kill -0 $rsync_pid 2>/dev/null; do
                if [ -d "$destination" ]; then
                    local copied_files=$(find "$destination" -type f 2>/dev/null | wc -l | tr -d ' ')
                    local percent=$((copied_files * 100 / dir_files))
                    printf "\r   üìã Progress: %d%% (%d/%d files)" $percent $copied_files $dir_files
                fi
                sleep 0.3
            done
            
            wait $rsync_pid
            local rsync_exit=$?
            printf "\n"
            
            if [ $rsync_exit -eq 0 ]; then
                echo -e "   ${GREEN}‚úÖ $relative_path copied successfully${NC}"
                ((total_copied++))
                
                # Show size information
                local size=$(du -sh "$destination" 2>/dev/null | cut -f1)
                if [ -n "$size" ]; then
                    echo -e "   ${BLUE}üìä Size: $size${NC}"
                fi
            else
                echo -e "   ${RED}‚ùå Failed to copy $relative_path${NC}"
                ((total_failed++))
            fi
        else
            # Fallback to cp with recursive copy
            echo "   Using cp for copying (rsync not available)..."
            if cp -R "$source" "$destination"; then
                echo -e "   ${GREEN}‚úÖ $relative_path copied successfully${NC}"
                ((total_copied++))
            else
                echo -e "   ${RED}‚ùå Failed to copy $relative_path${NC}"
                ((total_failed++))
            fi
        fi
        
        echo ""
    done
    
    # Summary
    echo -e "${GREEN}üìä Summary: $total_copied copied successfully${NC}"
    if [ $total_failed -gt 0 ]; then
        echo -e "${RED}üìä $total_failed failed${NC}"
        return 1
    fi
    
    return 0
}

setup_worktrees_dir() {
    # Create .worktrees directory if it doesn't exist
    mkdir -p .worktrees
    
    # Add .worktrees to .gitignore if not already there
    if ! grep -q "^\.worktrees/" .gitignore 2>/dev/null; then
        echo ".worktrees/" >> .gitignore
        echo -e "${GREEN}üìù Added .worktrees/ to .gitignore${NC}"
    fi
}

cmd_new() {
    local branch_name="${1:-task-$(date +%Y%m%d-%H%M%S)}"
    local base_branch="${2:-main}"
    local git_root=$(git rev-parse --show-toplevel)
    local worktree_dir="$git_root/.worktrees/${branch_name}"
    
    ensure_git_repo
    setup_worktrees_dir
    
    echo -e "${BLUE}üöÄ Creating new worktree...${NC}"
    echo "Branch: $branch_name"
    echo "Base: $base_branch"
    echo "Directory: $worktree_dir"
    
    # Create the worktree in organized structure
    git worktree add -b "$branch_name" "$worktree_dir" "$base_branch"
    
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}‚úÖ Worktree created successfully!${NC}"
        echo -e "${BLUE}üìÇ Directory: $(realpath $worktree_dir)${NC}"
        
        # Create a .git-wt-session file for session management
        echo "branch=$branch_name" > "$worktree_dir/.git-wt-session"
        echo "created=$(date -Iseconds)" >> "$worktree_dir/.git-wt-session"
        echo "base_branch=$base_branch" >> "$worktree_dir/.git-wt-session"
        
        # Copy and modify .env file
        local root_env="$git_root/.env"
        local worktree_env="$worktree_dir/.env"
        
        if [ -f "$root_env" ]; then
            echo -e "${BLUE}üìã Copying .env file to worktree...${NC}"
            cp "$root_env" "$worktree_env"
            
            # Modify DATABASE_URL
            _modify_database_url "$worktree_env" "$branch_name"
            
            echo -e "${GREEN}‚úÖ Environment file configured for worktree${NC}"
        else
            echo -e "${YELLOW}‚ö†Ô∏è  No .env file found in repository root${NC}"
        fi
        
        echo ""
        echo "Next steps:"
        echo "1. cd $worktree_dir"
        echo "2. Your app is ready to start with isolated database"
        echo "3. Use: claude code 'your task description'"
        echo ""
        echo "Or use: git wt switch $branch_name"
    else
        echo -e "${RED}‚ùå Failed to create worktree${NC}"
        exit 1
    fi
}

cmd_list() {
    local show_details=false
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -d|--details)
                show_details=true
                shift
                ;;
            -*)
                echo -e "${RED}Unknown option: $1${NC}"
                echo "Usage: git wt list [-d|--details]"
                return 1
                ;;
            *)
                echo -e "${RED}Unexpected argument: $1${NC}"
                echo "Usage: git wt list [-d|--details]"
                return 1
                ;;
        esac
    done
    
    ensure_git_repo
    
    if [ ! -d ".worktrees" ]; then
        echo "No .worktrees directory found"
        return 0
    fi
    
    if [ "$show_details" = true ]; then
        # Show detailed output (original format)
        echo -e "${BLUE}üìã Git Worktrees${NC}"
        echo "========================"
        
        local found_any=false
        for worktree_dir in .worktrees/*/; do
            if [ -d "$worktree_dir" ]; then
                found_any=true
                local branch_name=$(basename "$worktree_dir")
                local relative_path="$worktree_dir"
                
                echo ""
                echo -e "${GREEN}üåø Branch: $branch_name${NC}"
                echo -e "${BLUE}üìÅ Path: $relative_path${NC}"
                
                # Get commit info
                if [ -d "$worktree_dir/.git" ] || [ -f "$worktree_dir/.git" ]; then
                    cd "$worktree_dir"
                    local commit_info=$(git log -1 --format='%h %s' 2>/dev/null || echo 'No commits')
                    echo "üíæ Commit: $commit_info"
                    
                    # Check session info if available
                    if [ -f ".git-wt-session" ]; then
                        local created=$(grep "created=" .git-wt-session | cut -d'=' -f2)
                        local task=$(grep "^task=" .git-wt-session | cut -d'=' -f2-)
                        echo "‚è∞ Created: $created"
                        if [ -n "$task" ]; then
                            echo "üìù Task: $task"
                        fi
                    fi
                    
                    # Check for uncommitted changes and untracked files
                    local git_status=$(git status --porcelain 2>/dev/null)
                    if [ -n "$git_status" ]; then
                        echo -e "${YELLOW}üîÑ Status: Has uncommitted changes${NC}"
                    else
                        echo -e "${GREEN}‚úÖ Status: Clean${NC}"
                    fi
                    cd - > /dev/null
                fi
            fi
        done
        
        if [ "$found_any" != true ]; then
            echo "No worktrees found in .worktrees/"
        fi
    else
        # Show simplified output (branch, status)
        echo -e "${BLUE}üìã Git Worktrees${NC}"
        echo "========================"
        echo ""
        
        local found_any=false
        for worktree_dir in .worktrees/*/; do
            if [ -d "$worktree_dir" ]; then
                found_any=true
                local branch_name=$(basename "$worktree_dir")
                local status="Unknown"
                local status_color=""
                
                # Get status
                if [ -d "$worktree_dir/.git" ] || [ -f "$worktree_dir/.git" ]; then
                    cd "$worktree_dir"
                    # Check for both modified and untracked files
                    local git_status=$(git status --porcelain 2>/dev/null)
                    if [ -n "$git_status" ]; then
                        status="Modified"
                        status_color="${YELLOW}"
                    else
                        status="Clean"
                        status_color="${GREEN}"
                    fi
                    cd - > /dev/null
                fi
                
                echo -e "${GREEN}üåø ${branch_name}${NC} - ${status_color}${status}${NC}"
            fi
        done
        
        if [ "$found_any" != true ]; then
            echo "No worktrees found in .worktrees/"
        fi
    fi
}

cmd_switch() {
    local create_shell=false
    local branch_name=""
    
    ensure_git_repo
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -s|--shell)
                create_shell=true
                shift
                ;;
            -*)
                echo -e "${RED}Unknown option: $1${NC}"
                echo "Usage: git wt switch [-s|--shell] <branch-name>"
                return 1
                ;;
            *)
                branch_name="$1"
                break
                ;;
        esac
    done
    
    if [ -z "$branch_name" ]; then
        echo "Available worktrees:"
        cmd_list
        echo ""
        echo "Usage: git wt switch [-s|--shell] <branch-name>"
        return 1
    fi
    
    # Get git root before changing directories
    local git_root=$(git rev-parse --show-toplevel)
    local worktree_path="$git_root/.worktrees/$branch_name"
    
    if [ -d "$worktree_path" ]; then
        echo -e "${BLUE}üîÑ Switching to worktree: $branch_name${NC}"
        cd "$worktree_path"
        
        # Show current session info
        if [ -f ".git-wt-session" ]; then
            echo -e "${BLUE}üìã Session info:${NC}"
            cat .git-wt-session
        fi
        
        echo ""
        echo "Current directory: $(pwd)"
        echo "Git status:"
        git status --short
        echo ""
        
        if [ "$create_shell" = true ]; then
            # Check for node_modules copying before starting shell
            if _prompt_copy_node_modules "$worktree_path" "$git_root"; then
                _copy_node_modules
            fi
            
            # Start worktree shell
            echo ""
            echo -e "${GREEN}Starting worktree shell. Type 'exit' or use 'git wt root' to return.${NC}"
            export GIT_WT_SHELL=1
            export GIT_WT_ORIGINAL_DIR="$OLDPWD"
            export GIT_WT_BRANCH="$branch_name"
            PS1="(wt:$branch_name) $PS1" $SHELL
        else
            # Just change directory
            echo -e "${GREEN}‚úÖ Ready to work in worktree${NC}"
        fi
    else
        echo -e "${RED}‚ùå Worktree '$branch_name' not found in .worktrees/${NC}"
        echo "Available worktrees:"
        ls -1 .worktrees/ 2>/dev/null || echo "No worktrees found"
        return 1
    fi
}

cmd_resume() {
    local create_shell=false
    local branch_name=""
    
    ensure_git_repo
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -s|--shell)
                create_shell=true
                shift
                ;;
            -*)
                echo -e "${RED}Unknown option: $1${NC}"
                echo "Usage: git wt resume [-s|--shell] <branch-name>"
                return 1
                ;;
            *)
                branch_name="$1"
                break
                ;;
        esac
    done
    
    if [ -z "$branch_name" ]; then
        echo "Available worktrees to resume:"
        ls -1 .worktrees/ 2>/dev/null || echo "No worktrees found"
        echo ""
        echo "Usage: git wt resume [-s|--shell] <branch-name>"
        return 1
    fi
    
    if [ ! -d ".worktrees/$branch_name" ]; then
        echo -e "${RED}‚ùå Worktree '$branch_name' not found${NC}"
        return 1
    fi
    
    # Get git root before changing directories
    local git_root=$(git rev-parse --show-toplevel)
    
    cd ".worktrees/$branch_name"
    
    echo -e "${BLUE}üîÑ Resuming work in: $branch_name${NC}"
    
    # Show session info if available
    if [ -f ".git-wt-session" ]; then
        echo -e "${BLUE}üìã Previous session:${NC}"
        cat .git-wt-session | while IFS='=' read key value; do
            case $key in
                task) echo "  Task: $value" ;;
                created) echo "  Created: $value" ;;
                branch) echo "  Branch: $value" ;;
                base_branch) echo "  Base: $value" ;;
            esac
        done
        echo ""
    fi
    
    echo "Current status:"
    git status --short
    echo ""
    echo "Ready to continue work in $(pwd)"
    
    if [ "$create_shell" = true ]; then
        # Check for node_modules copying before starting shell
        if _prompt_copy_node_modules "$(pwd)" "$git_root"; then
            _copy_node_modules
        fi
        
        # Start worktree shell
        echo ""
        echo -e "${GREEN}Starting worktree shell. Type 'exit' or use 'git wt root' to return.${NC}"
        export GIT_WT_SHELL=1
        export GIT_WT_ORIGINAL_DIR="$OLDPWD"
        export GIT_WT_BRANCH="$branch_name"
        PS1="(wt:$branch_name) $PS1" $SHELL
    else
        # Just change directory
        echo -e "${GREEN}‚úÖ Ready to continue work in worktree${NC}"
    fi
}

cmd_status() {
    ensure_git_repo
    
    echo -e "${BLUE}üìä Git Worktrees Status${NC}"
    echo "================================"
    
    # Show current location
    echo "üìç Current location: $(pwd)"
    if [[ "$(pwd)" == *".worktrees/"* ]]; then
        echo "   You are currently in a worktree"
    else
        echo "   You are in the main repository"
    fi
    echo ""
    
    # Show all worktrees with detailed status
    cmd_list
    
    echo ""
    echo -e "${BLUE}üìà Summary:${NC}"
    local total_worktrees=$(ls -1d .worktrees/*/ 2>/dev/null | wc -l)
    echo "   Total worktrees: $total_worktrees"
    
    # Count worktrees with changes
    local dirty_count=0
    for worktree_dir in .worktrees/*/; do
        if [ -d "$worktree_dir" ]; then
            cd "$worktree_dir"
            local git_status=$(git status --porcelain 2>/dev/null)
            if [ -n "$git_status" ]; then
                ((dirty_count++))
            fi
            cd - > /dev/null
        fi
    done
    echo "   With changes: $dirty_count"
    echo "   Clean: $((total_worktrees - dirty_count))"
}

cmd_clean() {
    ensure_git_repo
    
    echo -e "${YELLOW}üßπ Git worktree cleanup${NC}"
    echo ""
    
    if [ ! -d ".worktrees" ]; then
        echo "No .worktrees directory found"
        return 0
    fi
    
    echo "Current worktrees in .worktrees/:"
    cmd_list
    echo ""
    
    # Show merged branches that can be cleaned up
    echo "Branches that have been merged to main:"
    git branch --merged main 2>/dev/null | grep -E "(task-|feature-|fix-)" | sed 's/^[ *]*//' | while read branch; do
        if [ -d ".worktrees/$branch" ]; then
            echo "  üìÅ $branch (in .worktrees/)"
        fi
    done
    echo ""
    
    read -p "Enter branch name to remove (or 'auto' for all merged): " branch_name
    
    if [ "$branch_name" = "auto" ]; then
        # Auto-cleanup merged branches
        git branch --merged main 2>/dev/null | grep -E "(task-|feature-|fix-)" | sed 's/^[ *]*//' | while read branch; do
            if [ "$branch" != "main" ] && [ "$branch" != "master" ] && [ -d ".worktrees/$branch" ]; then
                echo -e "${YELLOW}üóëÔ∏è  Removing worktree for branch: $branch${NC}"
                git worktree remove ".worktrees/$branch" 2>/dev/null || true
                git branch -d "$branch" 2>/dev/null || true
            fi
        done
    elif [ -n "$branch_name" ]; then
        # Remove specific branch
        if [ -d ".worktrees/$branch_name" ]; then
            git worktree remove ".worktrees/$branch_name"
            git branch -d "$branch_name"
            echo -e "${GREEN}‚úÖ Removed worktree: $branch_name${NC}"
        else
            echo -e "${RED}‚ùå Branch $branch_name not found in .worktrees/${NC}"
        fi
    fi
}

cmd_task() {
    local task_description="$1"
    local branch_name="${2:-task-$(date +%Y%m%d-%H%M%S)}"
    
    if [ -z "$task_description" ]; then
        echo "Usage: git wt task 'task description' [branch-name]"
        echo "Example: git wt task 'Add user authentication system' auth-feature"
        exit 1
    fi
    
    ensure_git_repo
    
    # Create the worktree
    cmd_new "$branch_name"
    
    if [ $? -eq 0 ]; then
        # Switch to the new worktree
        cd ".worktrees/$branch_name"
        
        # Save task description to session file
        echo "task=$task_description" >> .git-wt-session
        echo "task_started=$(date -Iseconds)" >> .git-wt-session
        
        echo -e "${BLUE}ü§ñ Starting Claude Code task in worktree...${NC}"
        echo "Task: $task_description"
        echo ""
        
        # Start Claude Code with the task
        claude code "$task_description"
    fi
}

cmd_remove() {
    local force_remove=false
    local branch_name=""
    
    ensure_git_repo
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -f|--force)
                force_remove=true
                shift
                ;;
            -*)
                echo -e "${RED}Unknown option: $1${NC}"
                echo "Usage: git wt remove [-f|--force] <branch-name>"
                return 1
                ;;
            *)
                branch_name="$1"
                break
                ;;
        esac
    done
    
    if [ -z "$branch_name" ]; then
        echo "Available worktrees to remove:"
        cmd_list
        echo ""
        echo "Usage: git wt remove [-f|--force] <branch-name>"
        return 1
    fi
    
    local git_root=$(git rev-parse --show-toplevel)
    local worktree_path="$git_root/.worktrees/$branch_name"
    
    if [ ! -d "$worktree_path" ]; then
        echo -e "${RED}‚ùå Worktree '$branch_name' not found in .worktrees/${NC}"
        echo "Available worktrees:"
        ls -1 .worktrees/ 2>/dev/null || echo "No worktrees found"
        return 1
    fi
    
    # Check if currently in the worktree we're trying to remove
    if _is_in_worktree_shell && [ "$GIT_WT_BRANCH" = "$branch_name" ]; then
        echo -e "${RED}‚ùå Cannot remove worktree '$branch_name' - you are currently in its shell${NC}"
        echo -e "${YELLOW}üí° Use 'git wt root' to exit the worktree shell first${NC}"
        return 1
    fi
    
    # Check for uncommitted changes unless force flag is used
    if [ "$force_remove" != true ]; then
        cd "$worktree_path"
        local git_status=$(git status --porcelain 2>/dev/null)
        if [ -n "$git_status" ]; then
            echo -e "${RED}‚ùå Cannot remove worktree '$branch_name' - has uncommitted changes:${NC}"
            echo ""
            git status --short
            echo ""
            echo -e "${YELLOW}üí° Use 'git wt remove -f $branch_name' to force removal${NC}"
            cd - > /dev/null
            return 1
        fi
        cd - > /dev/null
    fi
    
    echo -e "${YELLOW}üóëÔ∏è  Removing worktree: $branch_name${NC}"
    
    # Remove the worktree
    git worktree remove "$worktree_path" --force 2>/dev/null
    
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}‚úÖ Worktree removed successfully${NC}"
        
        # Delete the branch
        if git show-ref --verify --quiet "refs/heads/$branch_name"; then
            if [ "$force_remove" = true ]; then
                git branch -D "$branch_name" 2>/dev/null
                if [ $? -eq 0 ]; then
                    echo -e "${GREEN}‚úÖ Branch '$branch_name' deleted (forced)${NC}"
                else
                    echo -e "${YELLOW}‚ö†Ô∏è  Failed to delete branch '$branch_name'${NC}"
                fi
            else
                git branch -d "$branch_name" 2>/dev/null
                if [ $? -eq 0 ]; then
                    echo -e "${GREEN}‚úÖ Branch '$branch_name' deleted${NC}"
                else
                    echo -e "${YELLOW}‚ö†Ô∏è  Branch '$branch_name' not deleted - may have unmerged commits${NC}"
                    echo -e "${YELLOW}üí° Use 'git branch -D $branch_name' to force delete${NC}"
                fi
            fi
        else
            echo -e "${YELLOW}‚ö†Ô∏è  Branch '$branch_name' not found or already deleted${NC}"
        fi
        
        echo ""
        echo -e "${BLUE}üìä Remaining worktrees:${NC}"
        cmd_list
    else
        echo -e "${RED}‚ùå Failed to remove worktree${NC}"
        return 1
    fi
}

cmd_root() {
    ensure_git_repo
    
    # Check if we're in a worktree shell and exit if so
    if _exit_worktree_shell; then
        return 0
    fi
    
    # Regular root switching logic
    local git_root=$(git rev-parse --show-toplevel)
    
    echo -e "${BLUE}üè† Switching to repository root...${NC}"
    cd "$git_root"
    
    echo "üìç Current directory: $(pwd)"
    echo "üåø Current branch: $(git branch --show-current)"
    echo ""
    
    # Show git status
    echo "Git status:"
    git status --short
    echo ""
    
    # Show available worktrees
    if [ -d ".worktrees" ]; then
        echo -e "${BLUE}üìã Available worktrees:${NC}"
        ls -1 .worktrees/ 2>/dev/null || echo "No worktrees found"
        echo ""
    fi
    
    echo -e "${GREEN}‚úÖ Now in repository root directory${NC}"
}

# =============================================================================
# MAIN COMMAND DISPATCHER
# =============================================================================

case "${1:-help}" in
    "new"|"add")
        shift
        cmd_new "$@"
        ;;
    "list"|"ls")
        shift
        cmd_list "$@"
        ;;
    "switch"|"sw")
        shift
        cmd_switch "$@"
        ;;
    "resume"|"re")
        shift
        cmd_resume "$@"
        ;;
    "remove"|"rm")
        shift
        cmd_remove "$@"
        ;;
    "root"|"main")
        cmd_root
        ;;
    "status"|"st")
        cmd_status
        ;;
    "clean"|"cleanup")
        cmd_clean
        ;;
    "task"|"tk")
        shift
        cmd_task "$@"
        ;;
    "help"|"-h"|"--help"|*)
        show_help
        ;;
esac
